gunit Esql;


//
// Primitives
//
ID:
    "X" OK
    "XYZ" OK
    "Xyz" OK
    "XyZ" OK
    "_X" OK
    "1X" FAIL
INT:
    "1" OK

LITERAL:
    "'http://esql.ru'" OK

atom    :
   "10" -> "10"
   "\"Hello\"" -> "\"Hello\""
   "Var" -> "Var"
   "TRUE" -> "TRUE"
   "FALSE" -> "FALSE"
   "-10" -> (- 10)

sc_expr:
    "1 > 2" -> (> 1 2)
    "1 + 3 > 10" -> (> (+ 1 3) 10)
    "-1 > -2" -> ( > (- 1) (- 2))

concat_expr:
    "\"Hello\" || \", world\"" -> (|| "\"Hello\"" "\", world\"")

add_expr:
   "1 + 3" -> (+ 1 3)
   "3 - 1" -> (- 3 1)
   "1 + 2 + 3 - 4" -> (- (+ (+ 1 2) 3) 4)
   " a + x" -> (+ a x)
   "x + 10" -> ( + x 10)
   "(1 + 2) + (5 + 6)" -> ( + (+ 1 2) (+ 5 6))
   "(1 + x) + (x - 6)" -> ( + (+ 1 x) (- x 6))
   "1 - 3/4 + 5" -> (+ (- 1 (/ 3 4)) 5)
   "1 + 2 - (-3)" -> (- (+ 1 2) (- 3))

mult_expr:
    "5 * 6" -> (* 5 6)
    "6 / 10" -> (/ 6 10)
    "1 * 2 * 3 * 4" -> (* (* (* 1 2) 3) 4)
    "10 * -2" -> (* 10 (- 2))

logic_expr:
    "a > b AND x < y" -> (AND (> a b) (< x y))
    "NOT (a > b) = TRUE" -> "(= (NOT (> a b)) TRUE)"

dot_expr:
    "OutputRoot.XMLNSC.Data.Order" -> (. (. (. OutputRoot XMLNSC) Data) Order)

arr_expr:
    "Order[2]" -> ([ Order 2)
    "Order[]" -> ([ Order)

expr:
    "OutputRoot.XMLNS.Invoice.Purchases.Item[1];" -> (. (. (. (. OutputRoot XMLNS) Invoice) Purchases) ([ Item 1))
    "S.ACCOUNTNO = InputBody.AccountNumber" -> (. (. S (= ACCOUNTNO InputBody)) AccountNumber)


var_ns_decl:
    "DECLARE sp1 NAMESPACE 'http://esql.ru'" -> (NS sp1) (INIT sp1 'http://esql.ru')
    "DECLARE sp1, sp2 SHARED NAMESPACE 'http://esql.ru'" -> (NS (sp1 SHARED)) (NS (sp2 SHARED)) (INIT sp1 'http://esql.ru') (INIT sp2 'http://esql.ru')
    "DECLARE sp1 NAME 'http://esql.ru'" -> (NS sp1) (INIT sp1 'http://esql.ru')

var_only_decl:
    "DECLARE deployEnvironment EXTERNAL CHARACTER" -> (VAR (deployEnvironment CHARACTER EXTERNAL))
    "DECLARE deployEnvironment INT" -> (VAR (deployEnvironment INT))
    "DECLARE sp1, sp2 SHARED INT" -> (VAR (sp1 INT SHARED)) (VAR (sp2 INT SHARED))

const_decl:
     "DECLARE deployEnvironment EXTERNAL CONSTANT CHARACTER 'XYZ'" -> (CONSTANT (deployEnvironment CHARACTER EXTERNAL)) (INIT deployEnvironment 'XYZ')

var_ctor_decl:
    "DECLARE v INT -10" -> (VAR (v INT)) (INIT v (- 10))

set_stat:
    "SET x = y" -> "(SET (= x y))"
    "SET s = -10" -> (SET (= s (- 10)))
    "SET s = 1 - 3/4 + 5 * 2/(1+1)" -> (SET (= s (+ (- 1 (/ 3 4)) (/ (* 5 2) (+ 1 1)))))

if_stat:
    "IF 10 = 15 THEN END IF" -> (IF (COND (= 10 15)))
    "IF z = TRUE THEN SET x = 3 + 2; END IF" -> (IF (COND (= z TRUE) (SET (= x (+ 3 2)))))

    <<
    IF 10 <= 15 THEN
       SET result = 'Good';
    ELSE
       SET result = 'Bad';
    END IF
     >> -> (IF (COND (<= 10 15) (SET (= result 'Good'))) (ELSE (SET (= result 'Bad'))))

    <<
    IF 10 <= 15 THEN
       SET result = 'Good';
    ELSEIF x = 10 THEN
       SET x = x + 1;
    END IF
    >>
    -> (IF (COND (<= 10 15) (SET (= result 'Good'))) (COND (= x 10) (SET (= x (+ x 1)))))

    <<
    IF 10 <= 15 THEN
       SET result = 'Good';
       SET x = 0;
    ELSEIF x = 10 THEN
       SET x = x + 1;
    ELSE SET z = 0;
    END IF
    >>
    -> (IF (COND (<= 10 15) (SET (= result 'Good')) (SET (= x 0))) (COND (= x 10) (SET (= x (+ x 1)))) (ELSE (SET (= z 0))))

ret_stat:
    "RETURN" -> "RETURN"
    "RETURN 10" -> (RETURN 10)

beginend_stat:
    "BEGIN END" -> "BEGIN"
    "x: BEGIN END x" -> (BEGIN (PROPS (LABEL x)))
    "x: BEGIN ATOMIC DECLARE v INT; END x" -> (BEGIN (PROPS (LABEL x) (ATOMICITY ATOMIC)) (VAR (v INT)))

while_stat:
    <<
    WHILE x = TRUE DO
      SET z = z + 1;
    END WHILE;
    >>
    ->   (WHILE (COND (= x TRUE)) (SET(= z (+ z 1))))

attach_stat:
    "ATTACH ref1 TO OutputRoot.XMLNSC.Data.Order[2] AS LASTCHILD" -> (ATTACH ref1 (. (. (. OutputRoot XMLNSC) Data) ([ Order 2)) LASTCHILD)

detach_stat:
    "DETACH ref1" -> (DETACH ref1)

call_stat:
    "CALL myProc1() INTO cursor" -> (CALL myProc1 (INTO cursor))
    "CALL schema.myProc(10, 'X')" -> (CALL (. schema myProc) (PARAMS 10 'X'))

case_stat:
    <<
    CASE 10 > 5
      WHEN TRUE THEN
        CALL procedure1(10);
        CALL procedure1(15);
      WHEN FALSE THEN
        CALL procedure2(5);
    END CASE
    >>
    -> (CASE (COND (> 10 5)) (WHEN TRUE (CALL procedure1 (PARAMS 10)) (CALL procedure1 (PARAMS 15))) (WHEN FALSE (CALL procedure2 (PARAMS 5))))

    <<
    CASE
      WHEN 10 > 5 THEN
        CALL procedure1(10);
        CALL procedure1(15);
      ELSE
        CALL procedure2(5);
    END CASE
    >>
    -> (CASE (WHEN (> 10 5) (CALL procedure1 (PARAMS 10)) (CALL procedure1 (PARAMS 15))) (ELSE (CALL procedure2 (PARAMS 5))))

create_stat:
    <<
    CREATE LASTCHILD OF OutputRoot DOMAIN('MRM')
       PARSE(inBitStream, inEncoding, inCCSID, 'DP3UK14002001',
             'TestCase', 'XML1', options)
    >> -> (CREATE LASTCHILD OutputRoot (DOMAIN 'MRM') (PROPS (PARSE inBitStream inEncoding inCCSID 'DP3UK14002001' 'TestCase' 'XML1' options)))

func_decl_stat:
    <<
      CREATE FUNCTION itsFunction()
    >> -> (FUNCTION itsFunction)

handler_stat:
    "DECLARE CONTINUE HANDLER FOR SQLSTATE LIKE '%' BEGIN END;"
     -> (HANDLER CONTINUE (FOR (LIKE SQLSTATE '%')) (BODY BEGIN))

     "DECLARE EXIT HANDLER FOR SQLSTATE VALUE 'SELECT * FROM DUMMY' BEGIN END;"
     -> (HANDLER EXIT (FOR (VALUE SQLSTATE 'SELECT * FROM DUMMY')) (BODY BEGIN))

     "DECLARE EXIT HANDLER FOR SQLSTATE 'SELECT * FROM DUMMY' BEGIN END;"
     -> (HANDLER EXIT (FOR (SQLSTATE 'SELECT * FROM DUMMY')) (BODY BEGIN))

delete_from_stat:
    "DELETE FROM DATABASE.SHAREHOLDINGS AS S WHERE S.ACCOUNTNO = InputBody.AccountNumber"
    ->(DELETE (DATABASE SHAREHOLDINGS) (AS S) (WHERE (. (. S (= ACCOUNTNO InputBody)) AccountNumber)))
    "DELETE FROM DATABASE.{Source}.{Schema}.{Table}" -> (DELETE (DATABASE Source Schema Table))


delete_stat:
    "DELETE FIELD OutputRoot.XMLNS.Data.Folder1.Folder12" -> (DELETE FIELD (. (. (. (. OutputRoot XMLNS) Data) Folder1) Folder12))
    "DELETE LASTCHILD OF Cursor" -> (DELETE LASTCHILD Cursor)

eval_stat:
    "EVAL('SET ' || scalarVar1 || ' = 2;')" -> (EVAL (|| (|| 'SET ' scalarVar1) ' = 2;'))

for_stat:
    <<
    FOR source AS Environment.SourceData.Folder[] DO
     SET i = i + 1;
    END FOR
    >>
    -> (FOR source (AS (. (. Environment SourceData) ([ Folder))) (SET (= i (+ i 1))))

insert_stat:
    "INSERT INTO DATABASE.{Source}.{Schema}.{Table} (Name, Value) VALUES ('Joe', 12)"
    -> (INSERT (DATABASE Source Schema Table) (PARAMS Name Value) (VALUES 'Joe' 12))

iterate_stat:
    "ITERATE X" -> (ITERATE X)

leave_stat:
    "LEAVE X" -> (LEAVE X)

log_stat:
    "LOG EVENT SEVERITY 1 CATALOG 'BIPv600' MESSAGE 2951 VALUES(1,2,3,4)"
    -> (LOG (PROPS EVENT SEVERITY 1 CATALOG 'BIPv600' MESSAGE 2951) (VALUES 1 2 3 4))

    "LOG USER TRACE EXCEPTION VALUES(2951, 'DivideByZero')"
    -> (LOG (PROPS TRACE EXCEPTION) (VALUES 2951 'DivideByZero'))

loop_stat:
    <<
    X : LOOP
        SET i = i + 1;
    END LOOP X;
    >>
    -> (LOOP (PROPS X) (SET (= i (+ i 1))))

move_stat:
    "MOVE cursor FIRSTCHILD TYPE XML.Name 'Field1'" -> (MOVE cursor (FIRSTCHILD TYPE (. XML Name)))
    "MOVE sourceCursor NEXTSIBLING REPEAT TYPE NAME" -> (MOVE sourceCursor (REPEAT NEXTSIBLING TYPE NAME))

pass_stat:
    "PASSTHRU 'DROP TABLE Shop.Customers' TO DATABASE.DSN1" -> (PASSTHRU 'DROP TABLE Shop.Customers' (TO (DATABASE DSN1)))
    "PASSTHRU(myVar)" -> (PASSTHRU myVar)

propagate_stat:
    "PROPAGATE" -> "PROPAGATE"

module_stat:
    <<
    CREATE COMPUTE MODULE name

    END MODULE
    >>    -> (MODULE name COMPUTE)

repeat_stat:
    <<
    X : REPEAT
      SET i = i + 1;
    UNTIL
       i>= 3
    END REPEAT X
    >>
    -> (REPEAT (PROPS X) (>= i 3) (SET (= i (+ i 1))))